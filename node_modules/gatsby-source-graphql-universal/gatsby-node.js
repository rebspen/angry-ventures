"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

var _asyncToGenerator2 = _interopRequireDefault(require("@babel/runtime/helpers/asyncToGenerator"));

const uuidv4 = require(`uuid/v4`);

const _require = require(`gatsby/graphql`),
      buildSchema = _require.buildSchema,
      printSchema = _require.printSchema;

const _require2 = require(`graphql-tools`),
      makeRemoteExecutableSchema = _require2.makeRemoteExecutableSchema,
      transformSchema = _require2.transformSchema,
      introspectSchema = _require2.introspectSchema,
      RenameTypes = _require2.RenameTypes;

const _require3 = require(`apollo-link-http`),
      createHttpLink = _require3.createHttpLink;

const fetch = require(`node-fetch`);

const invariant = require(`invariant`);

const _require4 = require(`gatsby-source-graphql/transforms`),
      NamespaceUnderFieldTransform = _require4.NamespaceUnderFieldTransform,
      StripNonQueryTransform = _require4.StripNonQueryTransform;

const _require5 = require(`./getRootQuery`),
      getRootQuery = _require5.getRootQuery;

exports.sourceNodes =
/*#__PURE__*/
function () {
  var _ref = (0, _asyncToGenerator2.default)(function* ({
    actions,
    createNodeId,
    cache,
    createContentDigest
  }, options) {
    const addThirdPartySchema = actions.addThirdPartySchema,
          createNode = actions.createNode;
    const url = options.url,
          typeName = options.typeName,
          fieldName = options.fieldName,
          _options$headers = options.headers,
          headers = _options$headers === void 0 ? {} : _options$headers,
          _options$fetchOptions = options.fetchOptions,
          fetchOptions = _options$fetchOptions === void 0 ? {} : _options$fetchOptions,
          createLink = options.createLink,
          createSchema = options.createSchema,
          refetchInterval = options.refetchInterval;
    invariant(typeName && typeName.length > 0, `gatsby-source-graphql requires option \`typeName\` to be specified`);
    invariant(fieldName && fieldName.length > 0, `gatsby-source-graphql requires option \`fieldName\` to be specified`);
    invariant(url && url.length > 0 || createLink, `gatsby-source-graphql requires either option \`url\` or \`createLink\` callback`);
    let link;

    if (createLink) {
      link = yield createLink(options);
    } else {
      link = createHttpLink({
        uri: url,
        fetch,
        headers,
        fetchOptions
      });
    }

    let introspectionSchema;

    if (createSchema) {
      introspectionSchema = yield createSchema(options);
    } else {
      const cacheKey = `gatsby-source-graphql-schema-${typeName}-${fieldName}`;
      let sdl = yield cache.get(cacheKey);

      if (!sdl) {
        introspectionSchema = yield introspectSchema(link);
        sdl = printSchema(introspectionSchema);
      } else {
        introspectionSchema = buildSchema(sdl);
      }

      yield cache.set(cacheKey, sdl);
    }

    const remoteSchema = makeRemoteExecutableSchema({
      schema: introspectionSchema,
      link
    });
    const nodeId = createNodeId(`gatsby-source-graphql-${typeName}`);
    const node = createSchemaNode({
      id: nodeId,
      typeName,
      fieldName,
      createContentDigest
    });
    createNode(node);

    const resolver = (parent, args, context) => {
      context.nodeModel.createPageDependency({
        path: context.path,
        nodeId: nodeId
      });
      return {};
    };

    const schema = transformSchema(remoteSchema, [new StripNonQueryTransform(), new RenameTypes(name => `${typeName}_${name}`), new NamespaceUnderFieldTransform({
      typeName,
      fieldName,
      resolver
    })]);
    addThirdPartySchema({
      schema
    });

    if (process.env.NODE_ENV !== `production`) {
      if (refetchInterval) {
        const msRefetchInterval = refetchInterval * 1000;

        const refetcher = () => {
          createNode(createSchemaNode({
            id: nodeId,
            typeName,
            fieldName,
            createContentDigest
          }));
          setTimeout(refetcher, msRefetchInterval);
        };

        setTimeout(refetcher, msRefetchInterval);
      }
    }
  });

  return function (_x, _x2) {
    return _ref.apply(this, arguments);
  };
}();

function createSchemaNode({
  id,
  typeName,
  fieldName,
  createContentDigest
}) {
  const nodeContent = uuidv4();
  const nodeContentDigest = createContentDigest(nodeContent);
  return {
    id,
    typeName: typeName,
    fieldName: fieldName,
    parent: null,
    children: [],
    internal: {
      type: `GraphQLSource${typeName}`,
      contentDigest: nodeContentDigest,
      ignoreType: true
    }
  };
}

exports.onCreatePage = ({
  page,
  actions
}) => {
  const rootQuery = getRootQuery(page.componentPath);

  if (rootQuery) {
    page.context = page.context || {};
    page.context.rootQuery = rootQuery;
    actions.createPage(page);
  }
};

exports.onCreateWebpackConfig = ({
  stage,
  actions,
  getConfig
}) => {
  const config = getConfig();

  if (stage.indexOf('html') >= 0) {
    return;
  }

  const replaceRule = ruleUse => {
    if (ruleUse.loader && ruleUse.loader.indexOf(`gatsby/dist/utils/babel-loader.js`) >= 0) {
      ruleUse.loader = require.resolve(`gatsby-source-graphql-universal/babel-loader.js`);
    }
  };

  const traverseRule = rule => {
    if (rule.oneOf && Array.isArray(rule.oneOf)) {
      rule.oneOf.forEach(traverseRule);
    }

    if (rule.use) {
      if (Array.isArray(rule.use)) {
        rule.use.forEach(replaceRule);
      } else {
        replaceRule(rule.use);
      }
    }
  };

  config.module.rules.forEach(traverseRule);
  actions.replaceWebpackConfig(config);
};