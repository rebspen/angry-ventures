function __export(m) {
    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
}
Object.defineProperty(exports, "__esModule", { value: true });
var graphql_1 = require("graphql");
var utils_1 = require("./utils");
var generate_1 = require("./generate");
function makeExecutableSchema(_a) {
    var typeDefs = _a.typeDefs, _b = _a.resolvers, resolvers = _b === void 0 ? {} : _b, connectors = _a.connectors, logger = _a.logger, _c = _a.allowUndefinedInResolve, allowUndefinedInResolve = _c === void 0 ? true : _c, _d = _a.resolverValidationOptions, resolverValidationOptions = _d === void 0 ? {} : _d, directiveResolvers = _a.directiveResolvers, schemaDirectives = _a.schemaDirectives, _e = _a.parseOptions, parseOptions = _e === void 0 ? {} : _e, _f = _a.inheritResolversFromInterfaces, inheritResolversFromInterfaces = _f === void 0 ? false : _f;
    // Validate and clean up arguments
    if (typeof resolverValidationOptions !== 'object') {
        throw new generate_1.SchemaError('Expected `resolverValidationOptions` to be an object');
    }
    if (!typeDefs) {
        throw new generate_1.SchemaError('Must provide typeDefs');
    }
    // We allow passing in an array of resolver maps, in which case we merge them
    var resolverMap = Array.isArray(resolvers)
        ? resolvers
            .filter(function (resolverObj) { return typeof resolverObj === 'object'; })
            .reduce(utils_1.mergeDeep, {})
        : resolvers;
    // Arguments are now validated and cleaned up
    var schema = generate_1.buildSchemaFromTypeDefinitions(typeDefs, parseOptions);
    generate_1.addResolversToSchema({
        schema: schema,
        resolvers: resolverMap,
        resolverValidationOptions: resolverValidationOptions,
        inheritResolversFromInterfaces: inheritResolversFromInterfaces,
    });
    generate_1.assertResolversPresent(schema, resolverValidationOptions);
    if (!allowUndefinedInResolve) {
        addCatchUndefinedToSchema(schema);
    }
    if (logger != null) {
        addErrorLoggingToSchema(schema, logger);
    }
    if (typeof resolvers['__schema'] === 'function') {
        // TODO a bit of a hack now, better rewrite generateSchema to attach it there.
        // not doing that now, because I'd have to rewrite a lot of tests.
        generate_1.addSchemaLevelResolver(schema, resolvers['__schema']);
    }
    if (connectors != null) {
        // connectors are optional, at least for now. That means you can just import them in the resolve
        // function if you want.
        generate_1.attachConnectorsToContext(schema, connectors);
    }
    if (directiveResolvers != null) {
        generate_1.attachDirectiveResolvers(schema, directiveResolvers);
    }
    if (schemaDirectives != null) {
        utils_1.SchemaDirectiveVisitor.visitSchemaDirectives(schema, schemaDirectives);
    }
    return schema;
}
exports.makeExecutableSchema = makeExecutableSchema;
function decorateToCatchUndefined(fn, hint) {
    var resolve = fn == null ? graphql_1.defaultFieldResolver : fn;
    return function (root, args, ctx, info) {
        var result = resolve(root, args, ctx, info);
        if (typeof result === 'undefined') {
            throw new Error("Resolver for \"" + hint + "\" returned undefined");
        }
        return result;
    };
}
function addCatchUndefinedToSchema(schema) {
    utils_1.forEachField(schema, function (field, typeName, fieldName) {
        var errorHint = typeName + "." + fieldName;
        field.resolve = decorateToCatchUndefined(field.resolve, errorHint);
    });
}
exports.addCatchUndefinedToSchema = addCatchUndefinedToSchema;
function addErrorLoggingToSchema(schema, logger) {
    if (!logger) {
        throw new Error('Must provide a logger');
    }
    if (typeof logger.log !== 'function') {
        throw new Error('Logger.log must be a function');
    }
    utils_1.forEachField(schema, function (field, typeName, fieldName) {
        var errorHint = typeName + "." + fieldName;
        field.resolve = generate_1.decorateWithLogger(field.resolve, logger, errorHint);
    });
}
exports.addErrorLoggingToSchema = addErrorLoggingToSchema;
__export(require("./generate"));
//# sourceMappingURL=makeExecutableSchema.js.map